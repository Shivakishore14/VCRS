[
  {
    "name": "Date",
    "comment": " Library for working with dates. Email the mailing list if you encounter\nissues with internationalization or locale formatting.\n\n# Dates\n@docs Date, now\n\n# Conversions\n@docs fromString, toTime, fromTime\n\n# Extractions\n@docs year, month, Month, day, dayOfWeek, Day, hour, minute, second, millisecond\n\n",
    "aliases": [],
    "types": [
      {
        "name": "Date",
        "comment": " Representation of a date.\n",
        "args": [],
        "cases": []
      },
      {
        "name": "Day",
        "comment": " Represents the days of the week.\n",
        "args": [],
        "cases": [
          [
            "Mon",
            []
          ],
          [
            "Tue",
            []
          ],
          [
            "Wed",
            []
          ],
          [
            "Thu",
            []
          ],
          [
            "Fri",
            []
          ],
          [
            "Sat",
            []
          ],
          [
            "Sun",
            []
          ]
        ]
      },
      {
        "name": "Month",
        "comment": " Represents the month of the year.\n",
        "args": [],
        "cases": [
          [
            "Jan",
            []
          ],
          [
            "Feb",
            []
          ],
          [
            "Mar",
            []
          ],
          [
            "Apr",
            []
          ],
          [
            "May",
            []
          ],
          [
            "Jun",
            []
          ],
          [
            "Jul",
            []
          ],
          [
            "Aug",
            []
          ],
          [
            "Sep",
            []
          ],
          [
            "Oct",
            []
          ],
          [
            "Nov",
            []
          ],
          [
            "Dec",
            []
          ]
        ]
      }
    ],
    "values": [
      {
        "name": "day",
        "comment": " Extract the day of a given date. Given the date 23 June 1990 at 11:45AM\nthis returns the integer `23`.\n",
        "type": "Date.Date -> Int"
      },
      {
        "name": "dayOfWeek",
        "comment": " Extract the day of the week for a given date. Given the date 23 June\n1990 at 11:45AM this returns the day `Sat` as defined below.\n",
        "type": "Date.Date -> Date.Day"
      },
      {
        "name": "fromString",
        "comment": " Attempt to read a date from a string.\n",
        "type": "String -> Result.Result String Date.Date"
      },
      {
        "name": "fromTime",
        "comment": " Convert a time in milliseconds into a `Date`.\n\nA time is the number of milliseconds since\n[the Unix epoch](http://en.wikipedia.org/wiki/Unix_time).\n",
        "type": "Time.Time -> Date.Date"
      },
      {
        "name": "hour",
        "comment": " Extract the hour of a given date. Given the date 23 June 1990 at 11:45AM\nthis returns the integer `11`.\n",
        "type": "Date.Date -> Int"
      },
      {
        "name": "millisecond",
        "comment": " Extract the millisecond of a given date. Given the date 23 June 1990 at 11:45:30.123AM\nthis returns the integer `123`.\n",
        "type": "Date.Date -> Int"
      },
      {
        "name": "minute",
        "comment": " Extract the minute of a given date. Given the date 23 June 1990 at 11:45AM\nthis returns the integer `45`.\n",
        "type": "Date.Date -> Int"
      },
      {
        "name": "month",
        "comment": " Extract the month of a given date. Given the date 23 June 1990 at 11:45AM\nthis returns the month `Jun` as defined below.\n",
        "type": "Date.Date -> Date.Month"
      },
      {
        "name": "now",
        "comment": " Get the `Date` at the moment when this task is run.\n",
        "type": "Task.Task x Date.Date"
      },
      {
        "name": "second",
        "comment": " Extract the second of a given date. Given the date 23 June 1990 at 11:45AM\nthis returns the integer `0`.\n",
        "type": "Date.Date -> Int"
      },
      {
        "name": "toTime",
        "comment": " Convert a `Date` to a time in milliseconds.\n\nA time is the number of milliseconds since\n[the Unix epoch](http://en.wikipedia.org/wiki/Unix_time).\n",
        "type": "Date.Date -> Time.Time"
      },
      {
        "name": "year",
        "comment": " Extract the year of a given date. Given the date 23 June 1990 at 11:45AM\nthis returns the integer `1990`.\n",
        "type": "Date.Date -> Int"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  },
  {
    "name": "Random",
    "comment": " This library helps you generate pseudo-random values.\n\nThis library is all about building [`generators`](#Generator) for whatever\ntype of values you need. There are a bunch of primitive generators like\n[`bool`](#bool) and [`int`](#int) that you can build up into fancier\ngenerators with functions like [`list`](#list) and [`map`](#map).\n\nIt may be helpful to [read about JSON decoders][json] because they work very\nsimilarly.\n\n[json]: https://evancz.gitbooks.io/an-introduction-to-elm/content/interop/json.html\n\n> *Note:* This is an implementation of the Portable Combined Generator of\nL'Ecuyer for 32-bit computers. It is almost a direct translation from the\n[System.Random](http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html)\nmodule. It has a period of roughly 2.30584e18.\n\n# Generators\n@docs Generator\n\n# Primitive Generators\n@docs bool, int, float\n\n# Data Structure Generators\n@docs pair, list\n\n# Custom Generators\n@docs map, map2, map3, map4, map5, andThen\n\n# Generate Values\n@docs generate\n\n# Generate Values Manually\n@docs step, Seed, initialSeed\n\n# Constants\n@docs maxInt, minInt\n\n",
    "aliases": [],
    "types": [
      {
        "name": "Generator",
        "comment": " A `Generator` is like a recipe for generating certain random values. So a\n`Generator Int` describes how to generate integers and a `Generator String`\ndescribes how to generate strings.\n\nTo actually *run* a generator and produce the random values, you need to use\nfunctions like [`generate`](#generate) and [`initialSeed`](#initialSeed).\n",
        "args": [
          "a"
        ],
        "cases": []
      },
      {
        "name": "Seed",
        "comment": " A `Seed` is the source of randomness in this whole system. Whenever\nyou want to use a generator, you need to pair it with a seed.\n",
        "args": [],
        "cases": []
      }
    ],
    "values": [
      {
        "name": "andThen",
        "comment": " Chain random operations, threading through the seed. In the following\nexample, we will generate a random letter by putting together uppercase and\nlowercase letters.\n\n    letter : Generator Char\n    letter =\n      bool\n        |> andThen upperOrLower\n\n    upperOrLower : Bool -> Generator Char\n    upperOrLower b =\n      if b then uppercaseLetter else lowercaseLetter\n\n    -- bool : Generator Bool\n    -- uppercaseLetter : Generator Char\n    -- lowercaseLetter : Generator Char\n",
        "type": "(a -> Random.Generator b) -> Random.Generator a -> Random.Generator b"
      },
      {
        "name": "bool",
        "comment": " Create a generator that produces boolean values. The following example\nsimulates a coin flip that may land heads or tails.\n\n    type Flip = Heads | Tails\n\n    coinFlip : Generator Flip\n    coinFlip =\n        map (\\b -> if b then Heads else Tails) bool\n",
        "type": "Random.Generator Bool"
      },
      {
        "name": "float",
        "comment": " Generate floats in a given range. The following example is a generator\nthat produces decimals between 0 and 1.\n\n    probability : Generator Float\n    probability =\n        float 0 1\n",
        "type": "Float -> Float -> Random.Generator Float"
      },
      {
        "name": "generate",
        "comment": " Create a command that will generate random values.\n\nRead more about how to use this in your programs in [The Elm Architecture\ntutorial][arch] which has a section specifically [about random values][rand].\n\n[arch]: https://evancz.gitbooks.io/an-introduction-to-elm/content/architecture/index.html\n[rand]: https://evancz.gitbooks.io/an-introduction-to-elm/content/architecture/effects/random.html\n",
        "type": "(a -> msg) -> Random.Generator a -> Platform.Cmd.Cmd msg"
      },
      {
        "name": "initialSeed",
        "comment": " Create a &ldquo;seed&rdquo; of randomness which makes it possible to\ngenerate random values. If you use the same seed many times, it will result\nin the same thing every time! A good way to get an unexpected seed is to use\nthe current time.\n",
        "type": "Int -> Random.Seed"
      },
      {
        "name": "int",
        "comment": " Generate 32-bit integers in a given range.\n\n    int 0 10   -- an integer between zero and ten\n    int -5 5   -- an integer between -5 and 5\n\n    int minInt maxInt  -- an integer in the widest range feasible\n\nThis function *can* produce values outside of the range [[`minInt`](#minInt),\n[`maxInt`](#maxInt)] but sufficient randomness is not guaranteed.\n",
        "type": "Int -> Int -> Random.Generator Int"
      },
      {
        "name": "list",
        "comment": " Create a list of random values.\n\n    floatList : Generator (List Float)\n    floatList =\n        list 10 (float 0 1)\n\n    intList : Generator (List Int)\n    intList =\n        list 5 (int 0 100)\n\n    intPairs : Generator (List (Int, Int))\n    intPairs =\n        list 10 <| pair (int 0 100) (int 0 100)\n",
        "type": "Int -> Random.Generator a -> Random.Generator (List a)"
      },
      {
        "name": "map",
        "comment": " Transform the values produced by a generator. The following examples show\nhow to generate booleans and letters based on a basic integer generator.\n\n    bool : Generator Bool\n    bool =\n      map ((==) 1) (int 0 1)\n\n    lowercaseLetter : Generator Char\n    lowercaseLetter =\n      map (\\n -> Char.fromCode (n + 97)) (int 0 25)\n\n    uppercaseLetter : Generator Char\n    uppercaseLetter =\n      map (\\n -> Char.fromCode (n + 65)) (int 0 25)\n\n",
        "type": "(a -> b) -> Random.Generator a -> Random.Generator b"
      },
      {
        "name": "map2",
        "comment": " Combine two generators.\n\nThis function is used to define things like [`pair`](#pair) where you want to\nput two generators together.\n\n    pair : Generator a -> Generator b -> Generator (a,b)\n    pair genA genB =\n      map2 (,) genA genB\n\n",
        "type": "(a -> b -> c) -> Random.Generator a -> Random.Generator b -> Random.Generator c"
      },
      {
        "name": "map3",
        "comment": " Combine three generators. This could be used to produce random colors.\n\n    import Color\n\n    rgb : Generator Color.Color\n    rgb =\n      map3 Color.rgb (int 0 255) (int 0 255) (int 0 255)\n\n    hsl : Generator Color.Color\n    hsl =\n      map3 Color.hsl (map degrees (int 0 360)) (float 0 1) (float 0 1)\n",
        "type": "(a -> b -> c -> d) -> Random.Generator a -> Random.Generator b -> Random.Generator c -> Random.Generator d"
      },
      {
        "name": "map4",
        "comment": " Combine four generators.\n",
        "type": "(a -> b -> c -> d -> e) -> Random.Generator a -> Random.Generator b -> Random.Generator c -> Random.Generator d -> Random.Generator e"
      },
      {
        "name": "map5",
        "comment": " Combine five generators.\n",
        "type": "(a -> b -> c -> d -> e -> f) -> Random.Generator a -> Random.Generator b -> Random.Generator c -> Random.Generator d -> Random.Generator e -> Random.Generator f"
      },
      {
        "name": "maxInt",
        "comment": " The maximum value for randomly generated 32-bit ints: 2147483647 ",
        "type": "Int"
      },
      {
        "name": "minInt",
        "comment": " The minimum value for randomly generated 32-bit ints: -2147483648 ",
        "type": "Int"
      },
      {
        "name": "pair",
        "comment": " Create a pair of random values. A common use of this might be to generate\na point in a certain 2D space. Imagine we have a collage that is 400 pixels\nwide and 200 pixels tall.\n\n    randomPoint : Generator (Int,Int)\n    randomPoint =\n        pair (int -200 200) (int -100 100)\n\n",
        "type": "Random.Generator a -> Random.Generator b -> Random.Generator ( a, b )"
      },
      {
        "name": "step",
        "comment": " Generate a random value as specified by a given `Generator`.\n\nIn the following example, we are trying to generate a number between 0 and 100\nwith the `int 0 100` generator. Each time we call `step` we need to provide a\nseed. This will produce a random number and a *new* seed to use if we want to\nrun other generators later.\n\nSo here it is done right, where we get a new seed from each `step` call and\nthread that through.\n\n    seed0 = initialSeed 31415\n\n    -- step (int 0 100) seed0 ==> (42, seed1)\n    -- step (int 0 100) seed1 ==> (31, seed2)\n    -- step (int 0 100) seed2 ==> (99, seed3)\n\nNotice that we use different seeds on each line. This is important! If you use\nthe same seed, you get the same results.\n\n    -- step (int 0 100) seed0 ==> (42, seed1)\n    -- step (int 0 100) seed0 ==> (42, seed1)\n    -- step (int 0 100) seed0 ==> (42, seed1)\n",
        "type": "Random.Generator a -> Random.Seed -> ( a, Random.Seed )"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  },
  {
    "name": "Process",
    "comment": "\n\n# Processes\n@docs Id, spawn, sleep, kill\n\n## Future Plans\n\nRight now, this library is pretty sparse. For example, there is no public API\nfor processes to communicate with each other. This is a really important\nability, but it is also something that is extraordinarily easy to get wrong!\n\nI think the trend will be towards an Erlang style of concurrency, where every\nprocess has an “event queue” that anyone can send messages to. I currently\nthink the API will be extended to be more like this:\n\n    type Id exit msg\n\n    spawn : Task exit a -> Task x (Id exit Never)\n\n    kill : Id exit msg -> Task x ()\n\n    send : Id exit msg -> msg -> Task x ()\n\nA process `Id` will have two type variables to make sure all communication is\nvalid. The `exit` type describes the messages that are produced if the process\nfails because of user code. So if processes are linked and trapping errors,\nthey will need to handle this. The `msg` type just describes what kind of\nmessages this process can be sent by strangers.\n\nWe shall see though! This is just a draft that does not cover nearly everything\nit needs to, so the long-term vision for concurrency in Elm will be rolling out\nslowly as I get more data and experience.\n\nI ask that people bullish on compiling to node.js keep this in mind. I think we\ncan do better than the hopelessly bad concurrency model of node.js, and I hope\nthe Elm community will be supportive of being more ambitious, even if it takes\nlonger. That’s kind of what Elm is all about.\n",
    "aliases": [
      {
        "name": "Id",
        "comment": " A light-weight process that runs concurrently. You can use `spawn` to\nget a bunch of different tasks running in different processes. The Elm runtime\nwill interleave their progress. So if a task is taking too long, we will pause\nit at an `andThen` and switch over to other stuff.\n\n**Note:** We make a distinction between *concurrency* which means interleaving\ndifferent sequences and *parallelism* which means running different\nsequences at the exact same time. For example, a\n[time-sharing system](https://en.wikipedia.org/wiki/Time-sharing) is definitely\nconcurrent, but not necessarily parallel. So even though JS runs within a\nsingle OS-level thread, Elm can still run things concurrently.\n",
        "args": [],
        "type": "Platform.ProcessId"
      }
    ],
    "types": [],
    "values": [
      {
        "name": "kill",
        "comment": " Sometimes you `spawn` a process, but later decide it would be a waste to\nhave it keep running and doing stuff. The `kill` function will force a process\nto bail on whatever task it is running. So if there is an HTTP request in\nflight, it will also abort the request.\n",
        "type": "Process.Id -> Task.Task x ()"
      },
      {
        "name": "sleep",
        "comment": " Block progress on the current process for a given amount of time. The\nJavaScript equivalent of this is [`setTimeout`][setTimeout] which lets you\ndelay work until later.\n\n[setTimeout]: https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setTimeout\n",
        "type": "Time.Time -> Task.Task x ()"
      },
      {
        "name": "spawn",
        "comment": " Run a task in its own light-weight process. In the following example,\n`task1` and `task2` will be interleaved. If `task1` makes a long HTTP request\nor is just taking a long time, we can hop over to `task2` and do some work\nthere.\n\n    spawn task1\n      |> Task.andThen (\\_ -> spawn task2)\n\n**Note:** This creates a relatively restricted kind of `Process` because it\ncannot receive any messages. More flexibility for user-defined processes will\ncome in a later release!\n",
        "type": "Task.Task x a -> Task.Task y Process.Id"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  },
  {
    "name": "Json.Decode",
    "comment": " Turn JSON values into Elm values. Definitely check out this [intro to\nJSON decoders][guide] to get a feel for how this library works!\n\n[guide]: https://guide.elm-lang.org/interop/json.html\n\n# Primitives\n@docs Decoder, string, bool, int, float\n\n# Data Structures\n@docs nullable, list, array, dict, keyValuePairs\n\n# Object Primitives\n@docs field, at, index\n\n# Inconsistent Structure\n@docs maybe, oneOf\n\n# Run Decoders\n@docs decodeString, decodeValue, Value\n\n# Mapping\n\n**Note:** If you run out of map functions, take a look at [elm-decode-pipeline][pipe]\nwhich makes it easier to handle large objects, but produces lower quality type\nerrors.\n\n[pipe]: http://package.elm-lang.org/packages/NoRedInk/elm-decode-pipeline/latest\n\n@docs map, map2, map3, map4, map5, map6, map7, map8\n\n# Fancy Decoding\n@docs lazy, value, null, succeed, fail, andThen\n",
    "aliases": [
      {
        "name": "Value",
        "comment": " A JSON value.\n",
        "args": [],
        "type": "Json.Encode.Value"
      }
    ],
    "types": [
      {
        "name": "Decoder",
        "comment": " A value that knows how to decode JSON values.\n",
        "args": [
          "a"
        ],
        "cases": []
      }
    ],
    "values": [
      {
        "name": "andThen",
        "comment": " Create decoders that depend on previous results. If you are creating\nversioned data, you might do something like this:\n\n    info : Decoder Info\n    info =\n      field \"version\" int\n        |> andThen infoHelp\n\n    infoHelp : Int -> Decoder Info\n    infoHelp version =\n      case version of\n        4 ->\n          infoDecoder4\n\n        3 ->\n          infoDecoder3\n\n        _ ->\n          fail <|\n            \"Trying to decode info, but version \"\n            ++ toString version ++ \" is not supported.\"\n\n    -- infoDecoder4 : Decoder Info\n    -- infoDecoder3 : Decoder Info\n",
        "type": "(a -> Json.Decode.Decoder b) -> Json.Decode.Decoder a -> Json.Decode.Decoder b"
      },
      {
        "name": "array",
        "comment": " Decode a JSON array into an Elm `Array`.\n\n    decodeString (array int) \"[1,2,3]\"       == Ok (Array.fromList [1,2,3])\n    decodeString (array bool) \"[true,false]\" == Ok (Array.fromList [True,False])\n",
        "type": "Json.Decode.Decoder a -> Json.Decode.Decoder (Array.Array a)"
      },
      {
        "name": "at",
        "comment": " Decode a nested JSON object, requiring certain fields.\n\n    json = \"\"\"{ \"person\": { \"name\": \"tom\", \"age\": 42 } }\"\"\"\n\n    decodeString (at [\"person\", \"name\"] string) json  == Ok \"tom\"\n    decodeString (at [\"person\", \"age\" ] int   ) json  == Ok \"42\n\nThis is really just a shorthand for saying things like:\n\n    field \"person\" (field \"name\" string) == at [\"person\",\"name\"] string\n",
        "type": "List String -> Json.Decode.Decoder a -> Json.Decode.Decoder a"
      },
      {
        "name": "bool",
        "comment": " Decode a JSON boolean into an Elm `Bool`.\n\n    decodeString bool \"true\"              == Ok True\n    decodeString bool \"42\"                == Err ...\n    decodeString bool \"3.14\"              == Err ...\n    decodeString bool \"\\\"hello\\\"\"         == Err ...\n    decodeString bool \"{ \\\"hello\\\": 42 }\" == Err ...\n",
        "type": "Json.Decode.Decoder Bool"
      },
      {
        "name": "decodeString",
        "comment": " Parse the given string into a JSON value and then run the `Decoder` on it.\nThis will fail if the string is not well-formed JSON or if the `Decoder`\nfails for some reason.\n\n    decodeString int \"4\"     == Ok 4\n    decodeString int \"1 + 2\" == Err ...\n",
        "type": "Json.Decode.Decoder a -> String -> Result.Result String a"
      },
      {
        "name": "decodeValue",
        "comment": " Run a `Decoder` on some JSON `Value`. You can send these JSON values\nthrough ports, so that is probably the main time you would use this function.\n",
        "type": "Json.Decode.Decoder a -> Json.Decode.Value -> Result.Result String a"
      },
      {
        "name": "dict",
        "comment": " Decode a JSON object into an Elm `Dict`.\n\n    decodeString (dict int) \"{ \\\"alice\\\": 42, \\\"bob\\\": 99 }\"\n      == Dict.fromList [(\"alice\", 42), (\"bob\", 99)]\n",
        "type": "Json.Decode.Decoder a -> Json.Decode.Decoder (Dict.Dict String a)"
      },
      {
        "name": "fail",
        "comment": " Ignore the JSON and make the decoder fail. This is handy when used with\n`oneOf` or `andThen` where you want to give a custom error message in some\ncase.\n\nSee the [`andThen`](#andThen) docs for an example.\n",
        "type": "String -> Json.Decode.Decoder a"
      },
      {
        "name": "field",
        "comment": " Decode a JSON object, requiring a particular field.\n\n    decodeString (field \"x\" int) \"{ \\\"x\\\": 3 }\"            == Ok 3\n    decodeString (field \"x\" int) \"{ \\\"x\\\": 3, \\\"y\\\": 4 }\"  == Ok 3\n    decodeString (field \"x\" int) \"{ \\\"x\\\": true }\"         == Err ...\n    decodeString (field \"x\" int) \"{ \\\"y\\\": 4 }\"            == Err ...\n\n    decodeString (field \"name\" string) \"{ \\\"name\\\": \\\"tom\\\" }\" == Ok \"tom\"\n\nThe object *can* have other fields. Lots of them! The only thing this decoder\ncares about is if `x` is present and that the value there is an `Int`.\n\nCheck out [`map2`](#map2) to see how to decode multiple fields!\n",
        "type": "String -> Json.Decode.Decoder a -> Json.Decode.Decoder a"
      },
      {
        "name": "float",
        "comment": " Decode a JSON number into an Elm `Float`.\n\n    decodeString float \"true\"              == Err ..\n    decodeString float \"42\"                == Ok 42\n    decodeString float \"3.14\"              == Ok 3.14\n    decodeString float \"\\\"hello\\\"\"         == Err ...\n    decodeString float \"{ \\\"hello\\\": 42 }\" == Err ...\n",
        "type": "Json.Decode.Decoder Float"
      },
      {
        "name": "index",
        "comment": " Decode a JSON array, requiring a particular index.\n\n    json = \"\"\"[ \"alice\", \"bob\", \"chuck\" ]\"\"\"\n\n    decodeString (index 0 string) json  == Ok \"alice\"\n    decodeString (index 1 string) json  == Ok \"bob\"\n    decodeString (index 2 string) json  == Ok \"chuck\"\n    decodeString (index 3 string) json  == Err ...\n",
        "type": "Int -> Json.Decode.Decoder a -> Json.Decode.Decoder a"
      },
      {
        "name": "int",
        "comment": " Decode a JSON number into an Elm `Int`.\n\n    decodeString int \"true\"              == Err ...\n    decodeString int \"42\"                == Ok 42\n    decodeString int \"3.14\"              == Err ...\n    decodeString int \"\\\"hello\\\"\"         == Err ...\n    decodeString int \"{ \\\"hello\\\": 42 }\" == Err ...\n",
        "type": "Json.Decode.Decoder Int"
      },
      {
        "name": "keyValuePairs",
        "comment": " Decode a JSON object into an Elm `List` of pairs.\n\n    decodeString (keyValuePairs int) \"{ \\\"alice\\\": 42, \\\"bob\\\": 99 }\"\n      == [(\"alice\", 42), (\"bob\", 99)]\n",
        "type": "Json.Decode.Decoder a -> Json.Decode.Decoder (List ( String, a ))"
      },
      {
        "name": "lazy",
        "comment": " Sometimes you have JSON with recursive structure, like nested comments.\nYou can use `lazy` to make sure your decoder unrolls lazily.\n\n    type alias Comment =\n      { message : String\n      , responses : Responses\n      }\n\n    type Responses = Responses (List Comment)\n\n    comment : Decoder Comment\n    comment =\n      map2 Comment\n        (field \"message\" string)\n        (field \"responses\" (map Responses (list (lazy (\\_ -> comment)))))\n\nIf we had said `list comment` instead, we would start expanding the value\ninfinitely. What is a `comment`? It is a decoder for objects where the\n`responses` field contains comments. What is a `comment` though? Etc.\n\nBy using `list (lazy (\\_ -> comment))` we make sure the decoder only expands\nto be as deep as the JSON we are given. You can read more about recursive data\nstructures [here][].\n\n[here]: https://github.com/elm-lang/elm-compiler/blob/master/hints/recursive-alias.md\n",
        "type": "(() -> Json.Decode.Decoder a) -> Json.Decode.Decoder a"
      },
      {
        "name": "list",
        "comment": " Decode a JSON array into an Elm `List`.\n\n    decodeString (list int) \"[1,2,3]\"       == Ok [1,2,3]\n    decodeString (list bool) \"[true,false]\" == Ok [True,False]\n",
        "type": "Json.Decode.Decoder a -> Json.Decode.Decoder (List a)"
      },
      {
        "name": "map",
        "comment": " Transform a decoder. Maybe you just want to know the length of a string:\n\n    import String\n\n    stringLength : Decoder Int\n    stringLength =\n      map String.length string\n\nIt is often helpful to use `map` with `oneOf`, like when defining `nullable`:\n\n    nullable : Decoder a -> Decoder (Maybe a)\n    nullable decoder =\n      oneOf\n        [ null Nothing\n        , map Just decoder\n        ]\n",
        "type": "(a -> value) -> Json.Decode.Decoder a -> Json.Decode.Decoder value"
      },
      {
        "name": "map2",
        "comment": " Try two decoders and then combine the result. We can use this to decode\nobjects with many fields:\n\n    type alias Point = { x : Float, y : Float }\n\n    point : Decoder Point\n    point =\n      map2 Point\n        (field \"x\" float)\n        (field \"y\" float)\n\n    -- decodeString point \"\"\"{ \"x\": 3, \"y\": 4 }\"\"\" == Ok { x = 3, y = 4 }\n\nIt tries each individual decoder and puts the result together with the `Point`\nconstructor.\n",
        "type": "(a -> b -> value) -> Json.Decode.Decoder a -> Json.Decode.Decoder b -> Json.Decode.Decoder value"
      },
      {
        "name": "map3",
        "comment": " Try three decoders and then combine the result. We can use this to decode\nobjects with many fields:\n\n    type alias Person = { name : String, age : Int, height : Float }\n\n    person : Decoder Person\n    person =\n      map3 Person\n        (at [\"name\"] string)\n        (at [\"info\",\"age\"] int)\n        (at [\"info\",\"height\"] float)\n\n    -- json = \"\"\"{ \"name\": \"tom\", \"info\": { \"age\": 42, \"height\": 1.8 } }\"\"\"\n    -- decodeString person json == Ok { name = \"tom\", age = 42, height = 1.8 }\n\nLike `map2` it tries each decoder in order and then give the results to the\n`Person` constructor. That can be any function though!\n",
        "type": "(a -> b -> c -> value) -> Json.Decode.Decoder a -> Json.Decode.Decoder b -> Json.Decode.Decoder c -> Json.Decode.Decoder value"
      },
      {
        "name": "map4",
        "comment": "",
        "type": "(a -> b -> c -> d -> value) -> Json.Decode.Decoder a -> Json.Decode.Decoder b -> Json.Decode.Decoder c -> Json.Decode.Decoder d -> Json.Decode.Decoder value"
      },
      {
        "name": "map5",
        "comment": "",
        "type": "(a -> b -> c -> d -> e -> value) -> Json.Decode.Decoder a -> Json.Decode.Decoder b -> Json.Decode.Decoder c -> Json.Decode.Decoder d -> Json.Decode.Decoder e -> Json.Decode.Decoder value"
      },
      {
        "name": "map6",
        "comment": "",
        "type": "(a -> b -> c -> d -> e -> f -> value) -> Json.Decode.Decoder a -> Json.Decode.Decoder b -> Json.Decode.Decoder c -> Json.Decode.Decoder d -> Json.Decode.Decoder e -> Json.Decode.Decoder f -> Json.Decode.Decoder value"
      },
      {
        "name": "map7",
        "comment": "",
        "type": "(a -> b -> c -> d -> e -> f -> g -> value) -> Json.Decode.Decoder a -> Json.Decode.Decoder b -> Json.Decode.Decoder c -> Json.Decode.Decoder d -> Json.Decode.Decoder e -> Json.Decode.Decoder f -> Json.Decode.Decoder g -> Json.Decode.Decoder value"
      },
      {
        "name": "map8",
        "comment": "",
        "type": "(a -> b -> c -> d -> e -> f -> g -> h -> value) -> Json.Decode.Decoder a -> Json.Decode.Decoder b -> Json.Decode.Decoder c -> Json.Decode.Decoder d -> Json.Decode.Decoder e -> Json.Decode.Decoder f -> Json.Decode.Decoder g -> Json.Decode.Decoder h -> Json.Decode.Decoder value"
      },
      {
        "name": "maybe",
        "comment": " Helpful for dealing with optional fields. Here are a few slightly different\nexamples:\n\n    json = \"\"\"{ \"name\": \"tom\", \"age\": 42 }\"\"\"\n\n    decodeString (maybe (field \"age\"    int  )) json == Ok (Just 42)\n    decodeString (maybe (field \"name\"   int  )) json == Ok Nothing\n    decodeString (maybe (field \"height\" float)) json == Ok Nothing\n\n    decodeString (field \"age\"    (maybe int  )) json == Ok (Just 42)\n    decodeString (field \"name\"   (maybe int  )) json == Ok Nothing\n    decodeString (field \"height\" (maybe float)) json == Err ...\n\nNotice the last example! It is saying we *must* have a field named `height` and\nthe content *may* be a float. There is no `height` field, so the decoder fails.\n\nPoint is, `maybe` will make exactly what it contains conditional. For optional\nfields, this means you probably want it *outside* a use of `field` or `at`.\n",
        "type": "Json.Decode.Decoder a -> Json.Decode.Decoder (Maybe.Maybe a)"
      },
      {
        "name": "null",
        "comment": " Decode a `null` value into some Elm value.\n\n    decodeString (null False) \"null\" == Ok False\n    decodeString (null 42) \"null\"    == Ok 42\n    decodeString (null 42) \"42\"      == Err ..\n    decodeString (null 42) \"false\"   == Err ..\n\nSo if you ever see a `null`, this will return whatever value you specified.\n",
        "type": "a -> Json.Decode.Decoder a"
      },
      {
        "name": "nullable",
        "comment": " Decode a nullable JSON value into an Elm value.\n\n    decodeString (nullable int) \"13\"    == Ok (Just 13)\n    decodeString (nullable int) \"42\"    == Ok (Just 42)\n    decodeString (nullable int) \"null\"  == Ok Nothing\n    decodeString (nullable int) \"true\"  == Err ..\n",
        "type": "Json.Decode.Decoder a -> Json.Decode.Decoder (Maybe.Maybe a)"
      },
      {
        "name": "oneOf",
        "comment": " Try a bunch of different decoders. This can be useful if the JSON may come\nin a couple different formats. For example, say you want to read an array of\nnumbers, but some of them are `null`.\n\n    import String\n\n    badInt : Decoder Int\n    badInt =\n      oneOf [ int, null 0 ]\n\n    -- decodeString (list badInt) \"[1,2,null,4]\" == Ok [1,2,0,4]\n\nWhy would someone generate JSON like this? Questions like this are not good\nfor your health. The point is that you can use `oneOf` to handle situations\nlike this!\n\nYou could also use `oneOf` to help version your data. Try the latest format,\nthen a few older ones that you still support. You could use `andThen` to be\neven more particular if you wanted.\n",
        "type": "List (Json.Decode.Decoder a) -> Json.Decode.Decoder a"
      },
      {
        "name": "string",
        "comment": " Decode a JSON string into an Elm `String`.\n\n    decodeString string \"true\"              == Err ...\n    decodeString string \"42\"                == Err ...\n    decodeString string \"3.14\"              == Err ...\n    decodeString string \"\\\"hello\\\"\"         == Ok \"hello\"\n    decodeString string \"{ \\\"hello\\\": 42 }\" == Err ...\n",
        "type": "Json.Decode.Decoder String"
      },
      {
        "name": "succeed",
        "comment": " Ignore the JSON and produce a certain Elm value.\n\n    decodeString (succeed 42) \"true\"    == Ok 42\n    decodeString (succeed 42) \"[1,2,3]\" == Ok 42\n    decodeString (succeed 42) \"hello\"   == Err ... -- this is not a valid JSON string\n\nThis is handy when used with `oneOf` or `andThen`.\n",
        "type": "a -> Json.Decode.Decoder a"
      },
      {
        "name": "value",
        "comment": " Do not do anything with a JSON value, just bring it into Elm as a `Value`.\nThis can be useful if you have particularly crazy data that you would like to\ndeal with later. Or if you are going to send it out a port and do not care\nabout its structure.\n",
        "type": "Json.Decode.Decoder Json.Decode.Value"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  },
  {
    "name": "Time",
    "comment": " Library for working with time.\n\n# Time\n@docs Time, now, every\n\n# Units\n@docs millisecond, second, minute, hour,\n  inMilliseconds, inSeconds, inMinutes, inHours\n\n",
    "aliases": [
      {
        "name": "Time",
        "comment": " Type alias to make it clearer when you are working with time values.\nUsing the `Time` helpers like `second` and `inSeconds` instead of raw numbers\nis very highly recommended.\n",
        "args": [],
        "type": "Float"
      }
    ],
    "types": [],
    "values": [
      {
        "name": "every",
        "comment": " Subscribe to the current time. First you provide an interval describing how\nfrequently you want updates. Second, you give a tagger that turns a time into a\nmessage for your `update` function. So if you want to hear about the current\ntime every second, you would say something like this:\n\n    type Msg = Tick Time | ...\n\n    subscriptions model =\n      every second Tick\n\nCheck out the [Elm Architecture Tutorial][arch] for more info on how\nsubscriptions work.\n\n[arch]: https://github.com/evancz/elm-architecture-tutorial/\n\n**Note:** this function is not for animation! You need to use something based\non `requestAnimationFrame` to get smooth animations. This is based on\n`setInterval` which is better for recurring tasks like “check on something\nevery 30 seconds”.\n",
        "type": "Time.Time -> (Time.Time -> msg) -> Platform.Sub.Sub msg"
      },
      {
        "name": "hour",
        "comment": "",
        "type": "Time.Time"
      },
      {
        "name": "inHours",
        "comment": "",
        "type": "Time.Time -> Float"
      },
      {
        "name": "inMilliseconds",
        "comment": "",
        "type": "Time.Time -> Float"
      },
      {
        "name": "inMinutes",
        "comment": "",
        "type": "Time.Time -> Float"
      },
      {
        "name": "inSeconds",
        "comment": "",
        "type": "Time.Time -> Float"
      },
      {
        "name": "millisecond",
        "comment": " Units of time, making it easier to specify things like a half-second\n`(500 * millisecond)` without remembering Elm&rsquo;s underlying units of time.\n",
        "type": "Time.Time"
      },
      {
        "name": "minute",
        "comment": "",
        "type": "Time.Time"
      },
      {
        "name": "now",
        "comment": " Get the `Time` at the moment when this task is run.\n",
        "type": "Task.Task x Time.Time"
      },
      {
        "name": "second",
        "comment": "",
        "type": "Time.Time"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  },
  {
    "name": "Set",
    "comment": " A set of unique values. The values can be any comparable type. This\nincludes `Int`, `Float`, `Time`, `Char`, `String`, and tuples or lists\nof comparable types.\n\nInsert, remove, and query operations all take *O(log n)* time.\n\n# Sets\n@docs Set\n\n# Build\n@docs empty, singleton, insert, remove\n\n# Query\n@docs isEmpty, member, size\n\n# Combine\n@docs union, intersect, diff\n\n# Lists\n@docs toList, fromList\n\n# Transform\n@docs map, foldl, foldr, filter, partition\n\n",
    "aliases": [],
    "types": [
      {
        "name": "Set",
        "comment": " Represents a set of unique values. So `(Set Int)` is a set of integers and\n`(Set String)` is a set of strings.\n",
        "args": [
          "t"
        ],
        "cases": []
      }
    ],
    "values": [
      {
        "name": "diff",
        "comment": " Get the difference between the first set and the second. Keeps values\nthat do not appear in the second set.\n",
        "type": "Set.Set comparable -> Set.Set comparable -> Set.Set comparable"
      },
      {
        "name": "empty",
        "comment": " Create an empty set.\n",
        "type": "Set.Set a"
      },
      {
        "name": "filter",
        "comment": " Create a new set consisting only of elements which satisfy a predicate.\n",
        "type": "(comparable -> Bool) -> Set.Set comparable -> Set.Set comparable"
      },
      {
        "name": "foldl",
        "comment": " Fold over the values in a set, in order from lowest to highest.\n",
        "type": "(comparable -> b -> b) -> b -> Set.Set comparable -> b"
      },
      {
        "name": "foldr",
        "comment": " Fold over the values in a set, in order from highest to lowest.\n",
        "type": "(comparable -> b -> b) -> b -> Set.Set comparable -> b"
      },
      {
        "name": "fromList",
        "comment": " Convert a list into a set, removing any duplicates.\n",
        "type": "List comparable -> Set.Set comparable"
      },
      {
        "name": "insert",
        "comment": " Insert a value into a set.\n",
        "type": "comparable -> Set.Set comparable -> Set.Set comparable"
      },
      {
        "name": "intersect",
        "comment": " Get the intersection of two sets. Keeps values that appear in both sets.\n",
        "type": "Set.Set comparable -> Set.Set comparable -> Set.Set comparable"
      },
      {
        "name": "isEmpty",
        "comment": " Determine if a set is empty.\n",
        "type": "Set.Set a -> Bool"
      },
      {
        "name": "map",
        "comment": " Map a function onto a set, creating a new set with no duplicates.\n",
        "type": "(comparable -> comparable2) -> Set.Set comparable -> Set.Set comparable2"
      },
      {
        "name": "member",
        "comment": " Determine if a value is in a set.\n",
        "type": "comparable -> Set.Set comparable -> Bool"
      },
      {
        "name": "partition",
        "comment": " Create two new sets; the first consisting of elements which satisfy a\npredicate, the second consisting of elements which do not.\n",
        "type": "(comparable -> Bool) -> Set.Set comparable -> ( Set.Set comparable, Set.Set comparable )"
      },
      {
        "name": "remove",
        "comment": " Remove a value from a set. If the value is not found, no changes are made.\n",
        "type": "comparable -> Set.Set comparable -> Set.Set comparable"
      },
      {
        "name": "singleton",
        "comment": " Create a set with one value.\n",
        "type": "comparable -> Set.Set comparable"
      },
      {
        "name": "size",
        "comment": " Determine the number of elements in a set.\n",
        "type": "Set.Set a -> Int"
      },
      {
        "name": "toList",
        "comment": " Convert a set into a list, sorted from lowest to highest.\n",
        "type": "Set.Set comparable -> List comparable"
      },
      {
        "name": "union",
        "comment": " Get the union of two sets. Keep all values.\n",
        "type": "Set.Set comparable -> Set.Set comparable -> Set.Set comparable"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  },
  {
    "name": "Json.Encode",
    "comment": " Library for turning Elm values into Json values.\n\n# Encoding\n@docs encode, Value\n\n# Primitives\n@docs string, int, float, bool, null\n\n# Arrays\n@docs list, array\n\n# Objects\n@docs object\n",
    "aliases": [],
    "types": [
      {
        "name": "Value",
        "comment": " Represents a JavaScript value.\n",
        "args": [],
        "cases": []
      }
    ],
    "values": [
      {
        "name": "array",
        "comment": "",
        "type": "Array.Array Json.Encode.Value -> Json.Encode.Value"
      },
      {
        "name": "bool",
        "comment": "",
        "type": "Bool -> Json.Encode.Value"
      },
      {
        "name": "encode",
        "comment": " Convert a `Value` into a prettified string. The first argument specifies\nthe amount of indentation in the resulting string.\n\n    person =\n        object\n          [ (\"name\", string \"Tom\")\n          , (\"age\", int 42)\n          ]\n\n    compact = encode 0 person\n    -- {\"name\":\"Tom\",\"age\":42}\n\n    readable = encode 4 person\n    -- {\n    --     \"name\": \"Tom\",\n    --     \"age\": 42\n    -- }\n",
        "type": "Int -> Json.Encode.Value -> String"
      },
      {
        "name": "float",
        "comment": " Encode a Float. `Infinity` and `NaN` are encoded as `null`.\n",
        "type": "Float -> Json.Encode.Value"
      },
      {
        "name": "int",
        "comment": "",
        "type": "Int -> Json.Encode.Value"
      },
      {
        "name": "list",
        "comment": "",
        "type": "List Json.Encode.Value -> Json.Encode.Value"
      },
      {
        "name": "null",
        "comment": "",
        "type": "Json.Encode.Value"
      },
      {
        "name": "object",
        "comment": "",
        "type": "List ( String, Json.Encode.Value ) -> Json.Encode.Value"
      },
      {
        "name": "string",
        "comment": "",
        "type": "String -> Json.Encode.Value"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  },
  {
    "name": "Dict",
    "comment": " A dictionary mapping unique keys to values. The keys can be any comparable\ntype. This includes `Int`, `Float`, `Time`, `Char`, `String`, and tuples or\nlists of comparable types.\n\nInsert, remove, and query operations all take *O(log n)* time.\n\n# Dictionaries\n@docs Dict\n\n# Build\n@docs empty, singleton, insert, update, remove\n\n# Query\n@docs isEmpty, member, get, size\n\n# Lists\n@docs keys, values, toList, fromList\n\n# Transform\n@docs map, foldl, foldr, filter, partition\n\n# Combine\n@docs union, intersect, diff, merge\n\n",
    "aliases": [],
    "types": [
      {
        "name": "Dict",
        "comment": " A dictionary of keys and values. So a `(Dict String User)` is a dictionary\nthat lets you look up a `String` (such as user names) and find the associated\n`User`.\n",
        "args": [
          "k",
          "v"
        ],
        "cases": []
      }
    ],
    "values": [
      {
        "name": "diff",
        "comment": " Keep a key-value pair when its key does not appear in the second dictionary.\n",
        "type": "Dict.Dict comparable v -> Dict.Dict comparable v -> Dict.Dict comparable v"
      },
      {
        "name": "empty",
        "comment": " Create an empty dictionary. ",
        "type": "Dict.Dict k v"
      },
      {
        "name": "filter",
        "comment": " Keep a key-value pair when it satisfies a predicate. ",
        "type": "(comparable -> v -> Bool) -> Dict.Dict comparable v -> Dict.Dict comparable v"
      },
      {
        "name": "foldl",
        "comment": " Fold over the key-value pairs in a dictionary, in order from lowest\nkey to highest key.\n",
        "type": "(comparable -> v -> b -> b) -> b -> Dict.Dict comparable v -> b"
      },
      {
        "name": "foldr",
        "comment": " Fold over the key-value pairs in a dictionary, in order from highest\nkey to lowest key.\n",
        "type": "(comparable -> v -> b -> b) -> b -> Dict.Dict comparable v -> b"
      },
      {
        "name": "fromList",
        "comment": " Convert an association list into a dictionary. ",
        "type": "List ( comparable, v ) -> Dict.Dict comparable v"
      },
      {
        "name": "get",
        "comment": " Get the value associated with a key. If the key is not found, return\n`Nothing`. This is useful when you are not sure if a key will be in the\ndictionary.\n\n    animals = fromList [ (\"Tom\", Cat), (\"Jerry\", Mouse) ]\n\n    get \"Tom\"   animals == Just Cat\n    get \"Jerry\" animals == Just Mouse\n    get \"Spike\" animals == Nothing\n\n",
        "type": "comparable -> Dict.Dict comparable v -> Maybe.Maybe v"
      },
      {
        "name": "insert",
        "comment": " Insert a key-value pair into a dictionary. Replaces value when there is\na collision. ",
        "type": "comparable -> v -> Dict.Dict comparable v -> Dict.Dict comparable v"
      },
      {
        "name": "intersect",
        "comment": " Keep a key-value pair when its key appears in the second dictionary.\nPreference is given to values in the first dictionary.\n",
        "type": "Dict.Dict comparable v -> Dict.Dict comparable v -> Dict.Dict comparable v"
      },
      {
        "name": "isEmpty",
        "comment": " Determine if a dictionary is empty.\n\n    isEmpty empty == True\n",
        "type": "Dict.Dict k v -> Bool"
      },
      {
        "name": "keys",
        "comment": " Get all of the keys in a dictionary, sorted from lowest to highest.\n\n    keys (fromList [(0,\"Alice\"),(1,\"Bob\")]) == [0,1]\n",
        "type": "Dict.Dict comparable v -> List comparable"
      },
      {
        "name": "map",
        "comment": " Apply a function to all values in a dictionary.\n",
        "type": "(comparable -> a -> b) -> Dict.Dict comparable a -> Dict.Dict comparable b"
      },
      {
        "name": "member",
        "comment": " Determine if a key is in a dictionary. ",
        "type": "comparable -> Dict.Dict comparable v -> Bool"
      },
      {
        "name": "merge",
        "comment": " The most general way of combining two dictionaries. You provide three\naccumulators for when a given key appears:\n\n  1. Only in the left dictionary.\n  2. In both dictionaries.\n  3. Only in the right dictionary.\n\nYou then traverse all the keys from lowest to highest, building up whatever\nyou want.\n",
        "type": "(comparable -> a -> result -> result) -> (comparable -> a -> b -> result -> result) -> (comparable -> b -> result -> result) -> Dict.Dict comparable a -> Dict.Dict comparable b -> result -> result"
      },
      {
        "name": "partition",
        "comment": " Partition a dictionary according to a predicate. The first dictionary\ncontains all key-value pairs which satisfy the predicate, and the second\ncontains the rest.\n",
        "type": "(comparable -> v -> Bool) -> Dict.Dict comparable v -> ( Dict.Dict comparable v, Dict.Dict comparable v )"
      },
      {
        "name": "remove",
        "comment": " Remove a key-value pair from a dictionary. If the key is not found,\nno changes are made. ",
        "type": "comparable -> Dict.Dict comparable v -> Dict.Dict comparable v"
      },
      {
        "name": "singleton",
        "comment": " Create a dictionary with one key-value pair. ",
        "type": "comparable -> v -> Dict.Dict comparable v"
      },
      {
        "name": "size",
        "comment": " Determine the number of key-value pairs in the dictionary. ",
        "type": "Dict.Dict k v -> Int"
      },
      {
        "name": "toList",
        "comment": " Convert a dictionary into an association list of key-value pairs, sorted by keys. ",
        "type": "Dict.Dict comparable v -> List ( comparable, v )"
      },
      {
        "name": "union",
        "comment": " Combine two dictionaries. If there is a collision, preference is given\nto the first dictionary.\n",
        "type": "Dict.Dict comparable v -> Dict.Dict comparable v -> Dict.Dict comparable v"
      },
      {
        "name": "update",
        "comment": " Update the value of a dictionary for a specific key with a given function. ",
        "type": "comparable -> (Maybe.Maybe v -> Maybe.Maybe v) -> Dict.Dict comparable v -> Dict.Dict comparable v"
      },
      {
        "name": "values",
        "comment": " Get all of the values in a dictionary, in the order of their keys.\n\n    values (fromList [(0,\"Alice\"),(1,\"Bob\")]) == [\"Alice\", \"Bob\"]\n",
        "type": "Dict.Dict comparable v -> List v"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  },
  {
    "name": "Task",
    "comment": " Tasks make it easy to describe asynchronous operations that may fail, like\nHTTP requests or writing to a database. For more information, see the [Elm\ndocumentation on Tasks](http://guide.elm-lang.org/error_handling/task.html).\n\n# Basics\n@docs Task, succeed, fail\n\n# Mapping\n@docs map, map2, map3, map4, map5\n\n# Chaining\n@docs andThen, sequence\n\n# Errors\n@docs onError, mapError\n\n# Commands\n@docs perform, attempt\n\n",
    "aliases": [
      {
        "name": "Task",
        "comment": " Represents asynchronous effects that may fail. It is useful for stuff like\nHTTP.\n\nFor example, maybe we have a task with the type (`Task String User`). This means\nthat when we perform the task, it will either fail with a `String` message or\nsucceed with a `User`. So this could represent a task that is asking a server\nfor a certain user.\n",
        "args": [
          "err",
          "ok"
        ],
        "type": "Platform.Task err ok"
      }
    ],
    "types": [],
    "values": [
      {
        "name": "andThen",
        "comment": " Chain together a task and a callback. The first task will run, and if it is\nsuccessful, you give the result to the callback resulting in another task. This\ntask then gets run.\n\n    succeed 2\n      |> andThen (\\n -> succeed (n + 2))\n      -- succeed 4\n\nThis is useful for chaining tasks together. Maybe you need to get a user from\nyour servers *and then* lookup their picture once you know their name.\n",
        "type": "(a -> Task.Task x b) -> Task.Task x a -> Task.Task x b"
      },
      {
        "name": "attempt",
        "comment": " Command the Elm runtime to attempt a task that might fail!\n",
        "type": "(Result.Result x a -> msg) -> Task.Task x a -> Platform.Cmd.Cmd msg"
      },
      {
        "name": "fail",
        "comment": " A task that fails immediately when run.\n\n    fail \"file not found\" : Task String a\n",
        "type": "x -> Task.Task x a"
      },
      {
        "name": "map",
        "comment": " Transform a task.\n\n    map sqrt (succeed 9) -- succeed 3\n",
        "type": "(a -> b) -> Task.Task x a -> Task.Task x b"
      },
      {
        "name": "map2",
        "comment": " Put the results of two tasks together. If either task fails, the whole\nthing fails. It also runs in order so the first task will be completely\nfinished before the second task starts.\n\n    map2 (+) (succeed 9) (succeed 3) -- succeed 12\n",
        "type": "(a -> b -> result) -> Task.Task x a -> Task.Task x b -> Task.Task x result"
      },
      {
        "name": "map3",
        "comment": "",
        "type": "(a -> b -> c -> result) -> Task.Task x a -> Task.Task x b -> Task.Task x c -> Task.Task x result"
      },
      {
        "name": "map4",
        "comment": "",
        "type": "(a -> b -> c -> d -> result) -> Task.Task x a -> Task.Task x b -> Task.Task x c -> Task.Task x d -> Task.Task x result"
      },
      {
        "name": "map5",
        "comment": "",
        "type": "(a -> b -> c -> d -> e -> result) -> Task.Task x a -> Task.Task x b -> Task.Task x c -> Task.Task x d -> Task.Task x e -> Task.Task x result"
      },
      {
        "name": "mapError",
        "comment": " Transform the error value. This can be useful if you need a bunch of error\ntypes to match up.\n\n    type Error = Http Http.Error | WebGL WebGL.Error\n\n    getResources : Task Error Resource\n    getResources =\n      sequence [ mapError Http serverTask, mapError WebGL textureTask ]\n",
        "type": "(x -> y) -> Task.Task x a -> Task.Task y a"
      },
      {
        "name": "onError",
        "comment": " Recover from a failure in a task. If the given task fails, we use the\ncallback to recover.\n\n    fail \"file not found\"\n      |> onError (\\msg -> succeed 42)\n      -- succeed 42\n\n    succeed 9\n      |> onError (\\msg -> succeed 42)\n      -- succeed 9\n",
        "type": "(x -> Task.Task y a) -> Task.Task x a -> Task.Task y a"
      },
      {
        "name": "perform",
        "comment": " The only way to *do* things in Elm is to give commands to the Elm runtime.\nSo we describe some complex behavior with a `Task` and then command the runtime\nto `perform` that task. For example, getting the current time looks like this:\n\n    import Task\n    import Time exposing (Time)\n\n    type Msg = Click | NewTime Time\n\n    update : Msg -> Model -> ( Model, Cmd Msg )\n    update msg model =\n      case msg of\n        Click ->\n          ( model, Task.perform NewTime Time.now )\n\n        NewTime time ->\n          ...\n",
        "type": "(a -> msg) -> Task.Task Basics.Never a -> Platform.Cmd.Cmd msg"
      },
      {
        "name": "sequence",
        "comment": " Start with a list of tasks, and turn them into a single task that returns a\nlist. The tasks will be run in order one-by-one and if any task fails the whole\nsequence fails.\n\n    sequence [ succeed 1, succeed 2 ] -- succeed [ 1, 2 ]\n\nThis can be useful if you need to make a bunch of HTTP requests one-by-one.\n",
        "type": "List (Task.Task x a) -> Task.Task x (List a)"
      },
      {
        "name": "succeed",
        "comment": " A task that succeeds immediately when run.\n\n    succeed 42    -- results in 42\n",
        "type": "a -> Task.Task x a"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  },
  {
    "name": "Array",
    "comment": " A library for fast immutable arrays. The elements in an array must have the\nsame type. The arrays are implemented in Relaxed Radix Balanced-Trees for fast\nreads, updates, and appends.\n\n# Arrays\n@docs Array\n\n# Creating Arrays\n@docs empty, repeat, initialize, fromList\n\n# Basics\n@docs isEmpty, length, push, append\n\n# Get and Set\n@docs get, set\n\n# Taking Arrays Apart\n@docs slice, toList, toIndexedList\n\n# Mapping, Filtering, and Folding\n@docs map, indexedMap, filter, foldl, foldr\n",
    "aliases": [],
    "types": [
      {
        "name": "Array",
        "comment": " Representation of fast immutable arrays. You can create arrays of integers\n(`Array Int`) or strings (`Array String`) or any other type of value you can\ndream up.\n",
        "args": [
          "a"
        ],
        "cases": []
      }
    ],
    "values": [
      {
        "name": "append",
        "comment": " Append two arrays to a new one.\n\n    append (repeat 2 42) (repeat 3 81) == fromList [42,42,81,81,81]\n",
        "type": "Array.Array a -> Array.Array a -> Array.Array a"
      },
      {
        "name": "empty",
        "comment": " Return an empty array.\n\n    length empty == 0\n",
        "type": "Array.Array a"
      },
      {
        "name": "filter",
        "comment": " Keep only elements that satisfy the predicate:\n\n    filter isEven (fromList [1,2,3,4,5,6]) == (fromList [2,4,6])\n",
        "type": "(a -> Bool) -> Array.Array a -> Array.Array a"
      },
      {
        "name": "foldl",
        "comment": " Reduce an array from the left. Read `foldl` as &ldqu